\documentclass{article}

\usepackage[left=3cm,right=3cm,top=4cm,bottom=3cm]{geometry}
\usepackage{graphicx}
\usepackage{float}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{bytefield}
\usepackage{adjustbox}
\usepackage[backend=bibtex,style=authoryear]{biblatex}
\addbibresource{references.bib}


\title{\textbf{The MECA Block Cipher}}
\author{John Holly}
\date{\today}

\thispagestyle{plain}
\graphicspath{ {../img/key-schedule}{../img/metamorphic-engine} }

\begin{document}

\maketitle

\algblock{Input}{EndInput}
\algnotext{EndInput}
\algblock{Output}{EndOutput}
\algnotext{EndOutput}
\newcommand{\Desc}[2]{\State \makebox[2em][l]{#1}#2}

\begin{abstract}
  \centering
  \begin{minipage}{\dimexpr\paperwidth-10cm}
    In an effort of moving symmetric cipher abstractions up a level and simplifying implementation, a novel cipher was developed that metamorphically evolves and has data-dependent operations. The cipher is dependent on first and second-order cellular automata and metamorphic engines for encryption/decryption and key-scheduling with careful security considerations. The cipher was developed and made in an easily templated fashion to accomodate larger block-sizes and variable sized architectures.
  \end{minipage}
\end{abstract}

\bigskip

\section{Introduction}

In reality, I wanted to see if something I read about in a thriller novel could be done. Dan Brown's Digital Fortress mentioned a "rotating ciphertext" which I took as a data-dependent encryption, where the same operation isn't being used for individual blocks. My thesis was to simplify symmetric encryption and accomplish said goal using what has been used for S-boxes in the past. 

MECA (term is taken from \cite{MECAProperties} as a shorthand for second-order cellular automata; a higher-order automata) is a novel block cipher utilizing second-order cellular automata (MECA) and metamorphic engines in both encryption/decryption rounds and key scheduling.

\subsection{Cellular automata}

Cellular automata are discrete systems that undergo state transitions by iterating over each cell within the given dimensionality by means of a local transition rule. The operating area for a local transition is the cell itself and a specified number of neighbors. This sliding window across the state can be unbalanced but generally has an equal number of neighbors on either side of the target cell. For the purpose of this paper, the cellular space is one-dimensional and the neighborhood is the cell with its left and right neighbors. All CAs within this paper are two-state CAs, that is each cell is either a 1 or a 0. When the neighborhood reaches the boundary of the cellular space, a boundary condition must be put in place. For the purpose of this paper, the boundary is periodic (cyclic); borrowing a neighbor from the opposite side of the cellular state. 

\subsubsection{First-order (CA)}

When talking about orders of CAs, this is simply referring to the number of state transitions (timesteps) considered during a transition. First-order CAs are only aware of the current timestep. 

A CA can be described as a quadruple $(\mathcal{L},\mathcal{S},\mathcal{N},f)$, where $\mathcal{L}$ is the cellular space (state size) in one dimension, $\mathcal{S}$ is the finite set of states, $\mathcal{N} = (\vec{v_1}, \vec{v_2}, ..., \vec{v_m})$ is the association of a single cell's neighborhood of $m$ cells (including the cell itself) within $\mathcal{L}$, $f: \mathcal{S}^{m}\rightarrow\mathcal{S}$ is the local transition rule of the CA.

Let $r$ be the rule number selected where $r$ is between 0 and 255, $\mathcal{P}$ is the set of all permutations for a given neighborhood size where $\mathcal{N} \ni \mathcal{P}$, $i$ is the index of $\mathcal{N}$ in $\mathcal{P}$.

$$
  \mathcal{S}^{m}\rightarrow\mathcal{S} = f(\mathcal{N}, r)
$$

The local transition is defined as the selected rule number bit-shifted right by the index of the $\mathcal{N}$ in $\mathcal{P}$ ANDed with 1.

$$
  f(\mathcal{N}, r) = r \gg i \mathbin{\&} 1
$$

\subsubsection{Second-order (MECA)}

A second-order CA is defined similarly, with the exception of it tracking two timesteps $\mathcal{S}_t$ and $\mathcal{S}_{t-1}$. The second-order local transition is an extension of the definition of the first-order $f$ above. If the cell in $\mathcal{S}_{t-1} \ne f$ then the cell is set to 1, otherwise 0. By swapping the end state and preceding state the evolution can be reversed.

\subsection{Metamorphic Engines (CLUs)}

Metamorphism is a process that occurs in rocks where transformation to a rock of a different composition occurs. The data-dependent transformations in CA and MECA make this seem like a fitting nomenclature... dude.

There are two metamorphic engines in use, one using irreversible first-order CA rules as a one-way hashing function for the key-generating-key (unscheduled, the one of $b$ bytes specified as a parameter), and one used during encryption/decryption rounds selecting the second-order rules per round. The first-order engine selects from 3 class 4 (\cite{class4}) elementary CA rules. The second-order engine selects from 7 cherry-picked rules that also display globally chaotic behavior (\cite{MECAProperties}).

\section{Design and Motivation}

The design of MECA began with inspiration from a handful of other well known ciphers: RC6 (\cite{RC6}) for its small size and simplicity, speed, and elegant extensibility to different word sizes, rounds, and key length, Stone Cipher-192 (SC-192) (\cite{SC192}) for its crypto logic unit (metamorphic engine, or CLU), and a variety of papers I've read on novel ciphers utilizing first-order elementary cellular automata.

The MECA cipher was designed to be simplistic and easily understood to those without a deep knowledge of mathematics and cryptography from an implementation standpoint. The goals in mind were simplistic chaos that can be easily visualized, extensibility, efficiency in both hardware and software implementations, and exploitation of the reversibility of second-order cellular automata in place of traditional feistel networks. This is accomplished by having the current/previous or next timestep encoded in the  encrypted data's upper/lower half of blocks - this also simplifies encryption/decryption logic by requiring simply a swap of said states.

\section{Details}

Similarly to RC5 and RC6, MECA is fully parameterized and can be specified as MECA-$w$/$r$/$b$ with the word size (registers) being $w$ bits, $r$ encryption rounds, and $b$ bytes in the encryption key. Metamorphic logic units and cellular automata (both first-order and second-order) are the primitive building blocks throughout the cipher. Much like feistel networks can be run in reverse with the same logic as forwards, MECAs can be run in reverse by simply swapping the pre-initial and initial states (the previous and current timesteps [state] of the cellular automata) the forward pass (encryption) converged to.

\subsubsection{First-order CLU}

The first-order CLU selects a class 4 elementary CA rule based on the remainder ($mod$ 3) of the key-generating-key word at index $i$ of a specific iteration in the scheduling algorithm XORed with the current key schedule key at index $j$. The mappings are shown in table \ref{tab:first-order-clu} and the rules are shown evolved with random initial conditions in Figure~\ref{fig:rule54}, Figure~\ref{fig:rule110}, Figure~\ref{fig:rule137}.

The metamorphic engine for CA rule selection is defined by the piecewise function below.

$$
  m(x) = \cases{ 54  & $x$ $mod$ $3 = 0$ \cr
                 110 & $x$ $mod$ $3 = 1$ \cr
                 137 & $x$ $mod$ $3 = 2$ }
$$

\begin{table}[h!]
  \begin{center}
    \caption{First-order CLU mapping}
    \label{tab:first-order-clu}
    \begin{tabular}{l|r} % <-- Alignments: 1st column left, 2nd middle and 3rd right, with vertical lines in between
      \textbf{Remainder} & \textbf{Rule}\\
      \hline
      0 & 54\\
      1 & 110\\
      2 & 137\\
    \end{tabular}
  \end{center}
\end{table}

\begin{figure}[H]
  \begin{center}
    \begin{minipage}{0.48\textwidth}
      \caption{Rule 54}
      \label{fig:rule54}
      \centering
      \includegraphics[scale=.5]{54.png}
    \end{minipage}
    \begin{minipage}{0.48\textwidth}
      \caption{Rule 110}
      \label{fig:rule110}
      \centering
      \includegraphics[scale=.5]{110.png}
    \end{minipage}
  \end{center}
\end{figure}
\begin{figure}[H]
  \begin{center}
    \begin{minipage}{0.48\textwidth}
      \caption{Rule 137}
      \label{fig:rule137}
      \centering
      \includegraphics[scale=.5]{137.png}
    \end{minipage}
  \end{center}
\end{figure}

\subsubsection{Second-order CLU}

The second-order CLU selects a chaotic second-order rule based on the remainder ($mod$ 7) of the current state of the MECA (timestep $t$). The rules are shown evolved with random initial conditions in Figure~\ref{fig:rule75}, Figure~\ref{fig:rule86}, Figure~\ref{fig:rule89}, Figure~\ref{fig:rule149}, Figure~\ref{fig:rule166}, Figure~\ref{fig:rule173}, Figure~\ref{fig:rule229}.

The metamorphic engine for MECA rule selection is defined by the piecewise function below.

$$
  m(x) = \cases{ 75  & $x$ $mod$ $7 = 0$ \cr
                 86  & $x$ $mod$ $7 = 1$ \cr
                 89  & $x$ $mod$ $7 = 2$ \cr
                 149 & $x$ $mod$ $7 = 3$ \cr
                 166 & $x$ $mod$ $7 = 4$ \cr
                 173 & $x$ $mod$ $7 = 5$ \cr
                 229 & $x$ $mod$ $7 = 6$ \cr }
$$


\begin{figure}[H]
  \begin{center}
    \begin{minipage}{0.48\textwidth}
      \caption{Rule 75}
      \label{fig:rule75}
      \centering
      \includegraphics[scale=.5]{75.png}
    \end{minipage}
    \begin{minipage}{0.48\textwidth}
      \caption{Rule 86}
      \label{fig:rule86}
      \centering
      \includegraphics[scale=.5]{86.png}
    \end{minipage}
  \end{center}
\end{figure}
\begin{figure}[H]
  \begin{center}
    \begin{minipage}{0.48\textwidth}
      \caption{Rule 89}
      \label{fig:rule89}
      \centering
      \includegraphics[scale=.5]{89.png}
    \end{minipage}
    \begin{minipage}{0.48\textwidth}
      \caption{Rule 149}
      \label{fig:rule149}
      \centering
      \includegraphics[scale=.5]{149.png}
    \end{minipage}
  \end{center}
\end{figure}
\begin{figure}[H]
  \begin{center}
    \begin{minipage}{0.48\textwidth}
      \caption{Rule 166}
      \label{fig:rule166}
      \centering
      \includegraphics[scale=.5]{166.png}
    \end{minipage}
    \begin{minipage}{0.48\textwidth}
      \caption{Rule 173}
      \label{fig:rule173}
      \centering
      \includegraphics[scale=.5]{173.png}
    \end{minipage}
  \end{center}
\end{figure}
\begin{figure}[H]
  \begin{center}
    \begin{minipage}{0.48\textwidth}
      \caption{Rule 229}
      \label{fig:rule229}
      \centering
      \includegraphics[scale=.5]{229.png}
    \end{minipage}
  \end{center}
\end{figure}

\subsection{Key Schedule}

The key schedule uses the same magic constants for initialization as RC6. Let $P$ be the binary expansion of $e-2$ and $Q$ is the binary expansion of $\varphi-1$, where $\varphi$ is the golden ratio.

The function for the outcome of a single CA timestep with a given rule is defined by the function below. Let $m(x)$ be the desired metamorphic rule and $c(S_i, m(x))$ is the execution of the elementary CA, where $S_i$ is the resulting round key (for a given iteration).

$$
 S_i = c(S_i, m(x)) 
$$

\begin{algorithm}[H]
  \begin{algorithmic}
    \caption{Key schedule for MECA-$w$/$r$/$b$}\label{alg:schedule}
    \Input
      \Desc{L}{$b$ byte key preloaded into $c$-word array}
      \Desc{r}{number of rounds}
    \EndInput
    \Output
      \Desc{$S$}{$w$-bit round keys $S_{0, ..., 2r - 1}$}
    \EndOutput
    \State $S_0 \gets P$
    \For{$i \gets 1$ to $2r-1$} 
      \State $S_i \gets S_{i-1} + Q$
    \EndFor
    \State $j \gets 0$
    \State $i \gets 0$
    \For{$s \gets 0$ to max(c, $2r$)}
      \State $S_i \gets c(S_i, m(L_j \oplus S_i))$ 
      \State $i \gets i+1$ $mod$ $2r-1$
      \State $j \gets j+1$ $mod$ $c-1$
    \EndFor
  \end{algorithmic}
\end{algorithm}

\subsection{Encryption}

The encryption processes takes in 4 $w$-bit words of plaintext and creates two $w$-bit MECAs ($A$ and $B$) by taking the first/last two words and using them as the initial/pre-initial states.

The function for the outcome of a single MECA timestep with a given rule is defined by the function below. Let $m(x)$ be the desired metamorphic rule and $z(X, m(x))$ is the execution of the MECA.

$$
	X = z(X, m(x)) 
$$

\begin{algorithm}[H]
  \begin{algorithmic}
    \caption{Encryption (forward evolution) for MECA-$w$/$r$/$b$}\label{alg:encryption}
    \Input
      \Desc{$P$}{4 $w$-bit words of plaintext}
      \Desc{$S$}{key schedule of 2$r$ $w$-bit words}
    \EndInput
    \Output
      \Desc{$C$}{4 $w$-bit words of ciphertext}
    \EndOutput
    \State $A_{t-1} \gets P_0$
    \State $A_{t} \gets P_1$
	\State $B_{t-1} \gets P_2$
	\State $B_{t} \gets P_3$
	\State $j \gets 0$
	\For{$i \gets 0$ to $r - 1$}
		\State $A_{t} \gets A_{t} \oplus L_j$
		\State $A \gets z(A, m(A))$
		\State $B_{t} \gets B_{t} \oplus L_{j+1}$
		\State $B \gets z(B, m(B))$
		\State $j \gets j + 2$
    \EndFor
    \State $C_0 \gets A_{t-1}$
    \State $C_1 \gets A_{t}$
    \State $C_2 \gets B_{t-1}$
    \State $C_3 \gets B_{t}$
  \end{algorithmic}
\end{algorithm}

\subsection{Decryption}

The decryption processes takes in 4 $w$-bit words of ciphertext and creates two $w$-bit MECAs ($A$ and $B$) by taking the first/last two words and using them as the initial/pre-initial states, they are reversed during decryption.

The function for the outcome of a single MECA timestep in reverse with a given rule is defined by the function below. Let $m(x)$ be the desired metamorphic rule and $z(X, m(x))$ is the execution of the MECA.

$$
	X = z(X, m(x)) 
$$

\begin{algorithm}[H]
  \begin{algorithmic}
    \caption{Decryption (reverse evolution) for MECA-$w$/$r$/$b$}\label{alg:decryption}
    \Input
      \Desc{$C$}{4 $w$-bit words of ciphertext}
      \Desc{$S$}{key schedule of 2$r$ $w$-bit words}
    \EndInput
    \Output
      \Desc{$P$}{4 $w$-bit words of plaintext}
    \EndOutput
    \State $A_{t-1} \gets C_1$
    \State $A_{t} \gets C_0$
	\State $B_{t-1} \gets C_3$
	\State $B_{t} \gets C_2$
	\State $j \gets 2r-1$
	\For{$i \gets 0$ to $r - 1$}
		\State $A \gets z(A, m(A))$
		\State $A_{t-1} \gets A_{t-1} \oplus L_j$
		\State $B \gets z(B, m(B))$
		\State $B_{t-1} \gets B_{t-1} \oplus L_{j-1}$
		\State $j \gets j - 2$
    \EndFor
    \State $P_0 \gets A_{t-1}$
    \State $P_1 \gets A_{t}$
    \State $P_2 \gets B_{t-1}$
    \State $P_3 \gets B_{t}$
  \end{algorithmic}
\end{algorithm}

\section{Performance}

At optimal throughput, here are is the runtime for encryption and decryption for various word sizes. These tests were conducted from a C++ implementation running on an 12th Gen Intel(R) Core(TM) i5-1235UCPU @ 2.50GHz under Linux kernel 6.17.7-1.

\begin{table}[h!]
  \begin{center}
    \caption{Performance of various word sizes}
    \label{tab:performance}
    \begin{tabular}{l|r|r}
      \textbf{Word size} & \textbf{Encryption Execution Time} & \textbf{Decryption Execution Time}\\
      \hline
      16-bit & 31 us & 22 us\\
      32-bit & 36 us & 36 us\\
      64-bit & 65 us & 65 us\\
    \end{tabular}
  \end{center}
\end{table}

\section{Implementation Considerations}

Implementing the MECA cipher can pose its own challenges in terms of performance. Firstly, when creating the second-order automata $A$ and $B$ during half-rounds, you will need to efficiently divide the block in half which (depending on word size) can be up to 128-bits each. Finding a suitable container for the state is key to performance and avoiding strings at all cost. My solution for the reference implementation was using C++'s STL bitset. This way, you may efficiently create two 128-bit wide bitsets and left-shift/OR the two 64-bit words efficiently into the state of $A$ and $B$.

A future direction may be to use arrays of function pointers for metamorphic engines and compare performance, use optimized processor instructions/instruction sets, or implement this in hardware.

\section{Test Vectors}

\subsection{16-bit words (64-bit block)}

\begin{adjustbox}{max width=\textwidth, valign=t, minipage=4cm}
Plaintext \\
\\
\begin{bytefield}[endianness=little,bitwidth=0.11111\linewidth]{8}
	\bitheader{0-7} \\
	\bitbox{2}{1337} & \bitbox{2}{1337} & \bitbox{2}{1337} & \bitbox{2}{1337} \\
\end{bytefield} \\

Key \\
\\
\begin{bytefield}[endianness=little,bitwidth=0.11111\linewidth]{8}
	\bitheader{0-29} \\
	\bitbox{2}{4d79} & \bitbox{2}{2063} & \bitbox{2}{7269} & \bitbox{2}{6d65} & \bitbox{2}{2069} & \bitbox{2}{7320} & \bitbox{2}{7468} & \bitbox{2}{6174} & \bitbox{2}{206f} & \bitbox{2}{6620} & \bitbox{2}{6375} & \bitbox{2}{7269} & \bitbox{2}{6f73} & \bitbox{2}{6974} & \bitbox{2}{7900} \\
\end{bytefield} \\

Encrypted \\
\\
\begin{bytefield}[endianness=little,bitwidth=0.11111\linewidth]{8}
	\bitheader{0-7} \\
	\bitbox{2}{ee1c} & \bitbox{2}{fa14} & \bitbox{2}{68e1} & \bitbox{2}{51c8} \\
\end{bytefield} \\

Decrypted \\
\\
\begin{bytefield}[endianness=little,bitwidth=0.11111\linewidth]{8}
	\bitheader{0-7} \\
	\bitbox{2}{1337} & \bitbox{2}{1337} & \bitbox{2}{1337} & \bitbox{2}{1337} \\
\end{bytefield}
\end{adjustbox}

\subsection{32-bit words (128-bit block)}

\begin{adjustbox}{max width=\textwidth, valign=t, minipage=4cm}
Plaintext \\
\\
\begin{bytefield}[endianness=little,bitwidth=0.11111\linewidth]{8}
	\bitheader{0-15} \\
	\bitbox{4}{00001337} & \bitbox{4}{00001337} & \bitbox{4}{00001337} & \bitbox{4}{00001337} \\
\end{bytefield} \\

Key \\
\\
\begin{bytefield}[endianness=little,bitwidth=0.11111\linewidth]{8}
	\bitheader{0-31} \\
	\bitbox{4}{4d792063} & \bitbox{4}{72696d65} & \bitbox{4}{20697320} & \bitbox{4}{74686174} & \bitbox{4}{206f6620} & \bitbox{4}{63757269} & \bitbox{4}{6f736974} & \bitbox{4}{79000000} \\
\end{bytefield} \\

Encrypted \\
\\
\begin{bytefield}[endianness=little,bitwidth=0.11111\linewidth]{8}
	\bitheader{0-15} \\
	\bitbox{4}{d93041ec} & \bitbox{4}{e3fa5b94} & \bitbox{4}{01a2df58} & \bitbox{4}{71ca05ab} \\
\end{bytefield} \\

Decrypted \\
\\
\begin{bytefield}[endianness=little,bitwidth=0.11111\linewidth]{8}
	\bitheader{0-15} \\
	\bitbox{4}{00001337} & \bitbox{4}{00001337} & \bitbox{4}{00001337} & \bitbox{4}{00001337} \\
\end{bytefield} \\
\end{adjustbox} \\

\subsection{64-bit words (256-bit block)}

\begin{adjustbox}{max width=\textwidth, valign=t, minipage=4cm}
Plaintext \\
\\
\begin{bytefield}[endianness=little,bitwidth=0.11111\linewidth]{8}
	\bitheader{0-15} \\
	\bitbox{8}{0000000000001337} & \bitbox{8}{0000000000001337} & \bitbox{8}{0000000000001337} & \bitbox{8}{0000000000001337} \\
\end{bytefield} \\

Key \\
\\
\begin{bytefield}[endianness=little,bitwidth=0.11111\linewidth]{8}
	\bitheader{0-31} \\
	\bitbox{8}{4d79206372696d65} & \bitbox{8}{2069732074686174} & \bitbox{8}{206f662063757269} \bitbox{8}{6f73697479000000} \\
\end{bytefield} \\

Encrypted \\
\\
\begin{bytefield}[endianness=little,bitwidth=0.11111\linewidth]{8}
	\bitheader{0-15} \\
	\bitbox{8}{e72d26f7318d3da2} & \bitbox{8}{0ec874868d14ac9b} & \bitbox{8}{7d91e0e34ee12d46} & \bitbox{8}{0fd1e08f367ad342} \\
\end{bytefield} \\

Decrypted \\
\\
\begin{bytefield}[endianness=little,bitwidth=0.11111\linewidth]{8}
	\bitheader{0-15} \\
	\bitbox{8}{0000000000001337} & \bitbox{8}{0000000000001337} & \bitbox{8}{0000000000001337} & \bitbox{8}{0000000000001337} \\
\end{bytefield} \\
\end{adjustbox} \\

\section{Security}

First and foremost, when considering security - I wanted a large key size. The goal
was to use a first-order cellular automata - whether second-order or first-order for everything. With this in mind, without using an SMT solver, reversing a first-order cellular automata that is chaotic - such as the chosen rules is quite difficult and 
computationally expensive. A key size of up to 255 bytes is possible much like in RC6, as much of the key derivation function was adapted from it. The key schedule, however, is metamorphically evolved using globally chaotic (class 4) rules of elementary cellular automata fulfilling the desire of the previous sentence. This makes them mostly irreversible outside of plausible SMT solver attacks as demonstrated in PagedOut!'s second issue (\cite{pagedout}).

To make this block-cipher's operations data-dependent and thus harder to reverse the 
algorithm in use at a given time, a methodology was chosen from the Stone Cipher (\cite{SC192}) paper that selectively chooses globally chaotic rules to evolve from
identified as the "metamorphic engine" in this paper. As such, the encryption process
evolves during encryption and in key-scheduling, increasing confusion/diffusion. During
encryption/decryption - both the current and previous/next timestep are metamorphically evolved.

In terms of implementation security - the entire goal was to create a simple algorithm
that is elegant and easy to understand with a concise implementation, heavily focusing
on boolean algebra rather than heavy math.

\section{Flexibility and Future Direction}

The implementation of this cipher was designed to be templated as an easy means of 
accomodating higher block-sizes as future-proofing requires and architecture word
sizes grow, rules are also configurable and I have done auxiliary testing on rules
greater than 8 bits that have shown even more globally chaotic options in higher
bit-sizes once linear and other rules have been filtered away.

Another future direction may be to add a third metamorphic engine for the binary operation
of combining key with plaintext.

As cellular automata are highly efficient in hardware, I'd like to see FPGA and other
implementations that can remove the slowness of certain software executions to have 
real competition for existing block-ciphers. 

\section{Conclusions}

I was able to accomplish data-dependent encryption by adapting methodologies from the Stone Cipher (\cite{SC192}) paper and even extending that to key-scheduling with first-order cellular automata. This accomplished a simplification of symmetric ciphers in an adaptable and extensible manner for future architecture or block-size needs. While not the fastest, in its core implementation in C++ without special processor instructions or hardware acceleration, the goal of this paper was satisfied.

\section{Acknowledgements}

Friends, family, employers, being raised on the internet, tough times, and those who put up with me.

\printbibliography

\end{document}